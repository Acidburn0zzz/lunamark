#!/usr/bin/env lua
-- lunamark program

local lunamark = require("lunamark")
local alt_getopt = require("alt_getopt")
local cosmo = require("cosmo")

local function ensure_one_of(optval,s,ary)
  for i=1,#ary do
    if ary[i]==s then return true end
  end
  lunamark.util.err("Illegal value for " .. optval ..
     "\nLegal values are: " .. table.concat(ary,", "))
end

local version = [[
lunamark 0.2 (c) 2009-2011 John MacFarlane
]]

local usage = [[
Usage: lunamark [options] [file..] - convert text between formats

Options:
  --to,-t FORMAT             Target format (see --help-formats)
  --from,-f FORMAT           Source format (see --help-formats)
  --layout,-l LAYOUT         Whitespace in output (default|compact|minimize)
  --extensions,-X EXTENSIONS Syntax extensions to use (see --help-extensions)
  --output,-o FILE           Output file
  --standalone,-s            Add header and footer
  --template,-T FILE         Insert output into template
  --strict,-0                Disable markdown extensions 
  --version,-V               Version information
  --help,-h                  This message

FORMAT can be markdown or html for the source, and
markdown, html, html5, docbook, latex, or context for the target.

LAYOUT can be default, compact (no unnecessary blank lines), or
minimize (no unnecessary blank space).

EXTENSIONS is a comma-separated list of extensions, each optionally prefixed
by + (enable) or - (disable).  The following extensions are defined,
with the default setting given in parentheses:
  (-) containers    Put sections in containers (e.g. div or section tags)
  (+) startnum      Start number of an ordered list is significant 
  (-) smart         Smart typography (quotes, dashes, ellipses)
]]

local long_opts = {
  to = "t",
  from = "f",
  layout = "l",
  extensions = "X",
  output = "o",
  standalone = "s",
  template = "T",
  strict = "0",
  version = "V",
  help = "h"
}

local short_opts = "t:f:l:X:o:sT:0Vh"

local optarg,optind = alt_getopt.get_opts(arg, short_opts, long_opts)

if optarg.h then
  io.write(usage)
  os.exit(0)
end

if optarg.V then
  io.write(version)
  os.exit(0)
end

local from = optarg.f or "markdown"
local to = optarg.t or "html"

ensure_one_of("--from,-f", from, {"markdown","html"})
ensure_one_of("--to,-t", to,
  {"markdown","html","html5","docbook","latex","context"})

local reader = lunamark.reader[from]
if not reader then
  lunamark.util.err("Unknown reader: " .. tostring(from), 3)
end

local writer = lunamark.writer[to].new()
if not writer then
  lunamark.util.err("Unknown writer: " .. tostring(to), 5)
end

local extensions = {  -- defaults
  containers = false,
  startnum = true,
  smart = false,
}

if optarg["0"] then
  extensions = {}
end

local extensions_opt = optarg.X or ""
for x in extensions_opt:gmatch("[%+%-]?[%a]+") do
  local val = true
  if x:sub(1,1) == "+" then
    val = true
    x = x:sub(2)
  elseif x:sub(1,1) == "-" then
    val = false
    x = x:sub(2)
  end
  if type(extensions[x]) ~= "boolean" then
    lunamark.util.err("Unrecognized extension: ", x)
  else
    extensions[x] = val
  end
end

writer.options = extensions

local layout = optarg["l"] or "default"
ensure_one_of("--layout,-l",layout,{"default","compact","minimize"})
writer.containersep = writer.sep.container[layout]
writer.interblocksep = writer.sep.interblock[layout]

local args = {}
for i=optind,#arg do
  table.insert(args,arg[i])
end

local parse = reader.new(writer,{ smart = extensions.smart })

local inp
if #args == 0 then
  inp = io.read("*all") .. "\n"
else
  inpt = {}
  for _,f in ipairs(args) do
    io.input(f)
    table.insert(inpt, io.read("*all"))
  end
  inp = table.concat(inpt, "\n") .. "\n"
end
inp = inp:gsub("\r\n","\n") -- convert DOS line endings

local body, metadata = parse(inp)

local output = optarg.o
io.output(output)

local standalone = optarg.s
local template = optarg.T

if standalone and not template then
  template = "default"
end

if template then
  local contents = lunamark.util.find_template(template, to)
  local data = {}
  if metadata then data = metadata end
  data.body = body
  data.timestamp = os.date("%Y-%m-%d %X")
  data.sources = args
  data["if"] = cosmo.cif  -- this activates the "if" keyword
  local result = cosmo.fill(contents, data)
  io.write(result)
else
  io.write(body)
end

if not template then
  io.write("\n")
end
