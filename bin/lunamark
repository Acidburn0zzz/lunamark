#!/usr/bin/env lua
-- lunamark program

local manual = [===[
# NAME

lunamark - general markup converter

# SYNOPSIS

lunamark [options] [file..]

# DESCRIPTION

TODO

# OPTIONS

TODO

# EXTENSIONS


# EXAMPLES

TODO

# AUTHORS


]===]

local lunamark = require("lunamark")
local alt_getopt = require("alt_getopt")
local cosmo = require("cosmo")

local function ensure_one_of(optval,s,ary)
  for i=1,#ary do
    if ary[i]==s then return true end
  end
  lunamark.util.err("Illegal value for " .. optval ..
     "\nLegal values are: " .. table.concat(ary,", "))
end

local version = [[
lunamark 0.2 (c) 2009-2011 John MacFarlane
]]

local usage = [[
Usage: lunamark [options] [file..] - convert markdown to other formats

Options:
  --to,-t FORMAT             Target format
  --layout,-l LAYOUT         Whitespace in output (default|compact|minimize)
  --extensions,-X EXTENSIONS Syntax extensions to use
  --output,-o FILE           Output file
  --standalone,-s            Add header and footer
  --template,-T FILE         Insert output into template
  --data,-d K=V[,K=V..]      Set metadata to be passed to template
  --strict,-0                Disable markdown extensions
  --version,-V               Version information
  --man,-m                   Lunamark's man page (optionally in --to FORMAT)
  --help,-h                  This message

FORMAT can be html, html5, docbook, latex, context, or man.

LAYOUT can be default, compact (no unnecessary blank lines), or
minimize (no unnecessary blank space).

EXTENSIONS is a comma-separated list of extensions, each optionally prefixed
by + (enable) or - (disable).  The following extensions are defined,
with the default setting given in parentheses:
  (-) containers        Put sections in containers (e.g. div or section tags)
  (-) startnum          Start number of an ordered list is significant
  (-) smart             Smart typography (quotes, dashes, ellipses)
  (-) preserve_tabs     Don't expand tabs to spaces
  (-) notes             Footnotes
  (-) definition_lists  Definition lists
The keyword 'all' may also be used, to set all extensions simultaneously.
]]

local long_opts = {
  to = "t",
  layout = "l",
  extensions = "X",
  output = "o",
  standalone = "s",
  template = "T",
  data = "d",
  strict = "0",
  version = "V",
  man = "m",
  help = "h"
}

local short_opts = "t:l:X:o:sT:d:0Vmh"

local optarg,optind = alt_getopt.get_opts(arg, short_opts, long_opts)

if optarg.h then
  io.write(usage)
  os.exit(0)
end

if optarg.V then
  io.write(version)
  os.exit(0)
end

local to = optarg.t or ((optarg.m and "man") or "html")
ensure_one_of("--to,-t", to,
  {"markdown","html","html5","docbook","latex","context","man"})

local reader = lunamark.reader.markdown

local extensions = {  -- defaults
  containers = false,
  startnum = optarg.man,
  smart = false,
  preserve_tabs = false,
  notes = optarg.m,
  definition_lists = optarg.m,
}

if optarg["0"] then
  extensions = {}
end

local extensions_opt = optarg.X or ""
for x in extensions_opt:gmatch("[%+%-]?[%a_]+") do
  local val = true
  if x:sub(1,1) == "+" then
    val = true
    x = x:sub(2)
  elseif x:sub(1,1) == "-" then
    val = false
    x = x:sub(2)
  end
  if x == "all" then
    for k,_ in pairs(extensions) do
      extensions[k] = val
    end
  elseif type(extensions[x]) ~= "boolean" then
    lunamark.util.err("Unrecognized extension: ", x)
  else
    extensions[x] = val
  end
end

local output = optarg.o
io.output(output)

local writer_options = extensions

local layout = optarg["l"] or "default"
ensure_one_of("--layout,-l",layout,{"default","compact","minimize"})
writer_options.layout = layout

local writer = lunamark.writer[to].new(writer_options)
if not writer then
  lunamark.util.err("Unknown writer: " .. tostring(to), 5)
end

local reader_options = extensions
local parse = reader.new(writer, reader_options)

if optarg.m then
  local body = parse(manual)
  local data = {}
  data["if"] = cosmo.cif  -- this activates the "if" keyword
  data.body = body
  data.title = "lunamark"
  data.date = os.date("%Y-%m-%d")
  data.section = "1"
  local result = cosmo.fill(writer.template, data)
  io.write(result)
  os.exit(0)
end

local args = {}
for i=optind,#arg do
  table.insert(args,arg[i])
end

local inp
if #args == 0 then
  inp = io.read("*all") .. "\n"
else
  inpt = {}
  for _,f in ipairs(args) do
    io.input(f)
    table.insert(inpt, io.read("*all"))
  end
  inp = table.concat(inpt, "\n") .. "\n"
end
if inp:find("\r",1,true) then
  inp = inp:gsub("\r\n","\n") -- convert DOS line endings
end

local body, metadata = parse(inp)

local standalone = optarg.s
local template = optarg.T

local template_contents

if standalone and not template then
  template_contents = writer.template
end

if template then
  local template_name = template
  -- use writer name as extension if none provided
  if not template_name:match("%..+$") then
    template_name = template_name .. "." .. to
  end
  template_contents = lunamark.util.find_template(template_name)
  if not template_contents then
    lunamark.util.err("Could not find template '" .. template_name .. "'")
  end
end

if template_contents then
  local data = {}
  if metadata then data = metadata end
  if optarg.d then
    for x in string.gmatch(optarg.d, "[%w_]+=[^,]+") do
      local k,v = string.match(x, "([^=]*)=(.*)")
      data[k] = writer.string(v)
    end
  end
  data.body = body
  data.timestamp = os.date("%Y-%m-%d %X")
  data.sources = args
  data["if"] = cosmo.cif  -- this activates the "if" keyword
  local result = cosmo.fill(template_contents, data)
  io.write(result)
else
  io.write(body)
end

if not template_contents then
  io.write("\n")
end


