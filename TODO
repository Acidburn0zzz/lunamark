* TODO line spacing for docbook
* TODO line spacing for latex, context
* TODO indentation options?
* TODO tests
  adjust tests (or test runner) so that tidy isn't needed, as
  it can hide some errors, particularly in HTML output
* TODO Add metadata, return table as second value
* TODO templates
  - avoid excess newlines?
* TODO escaping in tex more complicated;
  don't escape in code blocks;
  urls
* TODO html reader based on htmlparser.lua, which I can modify?
* TODO latex reader - write peg
* TODO mathml - look at pandoc2?
* TODO extensions
  [ ] framework for individually controllabel exts
  [ ] footnotes
  [ ] smart
  [ ] defn lists
  [ ] fenced code blocks
  [ ] math
  [x] consecutive ordered/unordered list
  [ ] # enumerator in ordered lists
  [ ] non-numerical ordered lists
  [x] significant list start number
  [ ] tests for exts
* TODO make parser user-modifiable (as in v1)
  Good thought.  I've done something similar.  You can now pass in a
  modify_syntax function as an option.  This is a function from a table
  to a table, so you can perform arbitrary transformations on the input
  format grammar.  A simple example:
  
      function capify(t)
        t.Str = t.Str / string.upper
        return t
      end
  
      markdown2htmlCAPS = lunamark.converter("markdown", "html", { modify_syntax = capify })
  
  This gives you a markdown variant in which all strings are capitalized.
  
  Adding a handler for, say, wikilinks would be slightly more complicated.
  You'd have to do two things to the grammar table:
  (1) insert an entry for WikiLink
  (2) register WikiLink as an Inline element by modifying Inline
  
  So, something like this:
  
      function add_wikilink(t)
        t.WikiLink = --[[ whatever... ]] / write_wikilink
        t.Inline = lpeg.V("WikiLink") + t.Inline
        return t
      end
  
      function write_wikilink(s)
        -- code to write the wikilink as HTML
      end
  
  I hope this is flexible enough.

* TODO documentation w luadoc
* TODO add groff man writer
* TODO make epub tool
* TODO make pdf tool
* TODO documentation, including extending writer + parser

Notes on a possible macro system:  Simply add a function
to the writer:

    W.name = function(last,first)
      return first .. writer(space) .. writer.strong(last)
    end

    W.repeat = function(num,x)
      return string.rep(x, tonumber(num))
    end

When lunamark encounters %name{<inlines>}{<inlines>}
or %repeat[7]{Hi there%space}, it simply calls the writer.name function.

Note that writer.space is currently not a function; maybe that should
change for uniformity.  We may want macros with no arguments that
need to be functions: e.g. %currenttime.

Probably we'd need several types of arguments:

* parsed inline lists
* parsed block lists
* raw text

Also we'd have to know whether to parse as a block or an inline.
So perhaps we'd need two different kinds of macros.

* inline macros:

        %name{<inlines>}  -- with inline argument
        %name[raw text]   -- with raw argument

* block macros

        .admonition{<inlines>}{|  -- multiline block
        <blocks>
        |}

        .startsource[|
        multiline raw text - first newline ignored

        |]

These macros are all on the writer side. What about the reader side?
E.g. what if we want a macro

    #include[myfile.txt]

that reads myfile.txt and parses the source as markdown?
This can't happen in the writer.  But there could be a way to
register a reader macro.  This would simply call a match-time
parser function that directly modifies the input string.

